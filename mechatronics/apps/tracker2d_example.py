import dataclasses
import matplotlib.pyplot as plt
import numpy as np

from mechatronics.estimation import KalmanFilter
from mechatronics.models import VehicleModelA, VehicleModelAParams


@dataclasses.dataclass
class SimulationOptions:
    dt: float 
    """Sampling period to run the prediction step of the Kalman filter [s]""" 
    end_time: float
    """Length of the simulation to run [s]"""
    measurement_decimation_factor: int
    """How often the measurement is taken w.r.t. the sampling rate."""
    actual_noise_std: float
    """The actual noise placed position measurement of the simulated vehicle [m]"""
    motion_type: str
    """The motion the model of the vehicle moves in ("random", "cirle", "linear")"""
    start_at_origin: bool
    """Whether the vehicle model should start at the origin or a random coordinate."""
    start_at_random_speed: bool
    """Whether the vehicle model should start at the random speed or 0."""
    start_at_random_heading: bool
    """Whether the vehicle model should start at the random heading or 0."""
    draw_plots: bool
    """If true, the analysis is plotted."""
    measurement_std: float
    """The noise parameter on the position measurement used in the Kalman filter R matrix [m]"""
    accel_std: float
    """The noise parameter on the process used in the Kalman filter Q matrix [m/s/s]"""
    init_pos_std: float
    """Initial uncertainty of the position states in the Kalman filter [m]"""
    init_vel_std: float
    """Initial uncertainty of the velocity states in the Kalman filter [m/s]"""


@dataclasses.dataclass
class History:
    """
    This class stores results from the simulation to be plotted afterwards.
    """
    time: list
    vehicle_position: list
    vehicle_velocity: list
    measurement: list
    estimated_state: list
    estimated_covariance: list
    estimated_error: list
    measurement_innovation: list
    measurement_innovation_covariance: list


def create_kalman_filter(simopts: SimulationOptions) -> KalmanFilter:
    """
    The states we are estimating are the [xpos, ypos, xvel, yvel] of a vehicle moving in 2D plane.

    Parameters
    ----------
    simopts
        Simulation parameters used to configure the kalman filter.

    Returns
    -------
    kf
        The kalman filter.
    """
    F = np.array([[1, 0, simopts.dt, 0], [0, 1, 0, simopts.dt], [0, 0, 1, 0], [0, 0, 0, 1]])
    H = np.array([[1, 0, 0, 0], [0, 1, 0, 0]])
    alpha = 0.5 * simopts.dt * simopts.dt
    Q = simopts.accel_std *simopts. accel_std * np.diag([alpha, alpha, simopts.dt, simopts.dt])
    R = simopts.measurement_std * simopts.measurement_std * np.eye(2)
    P0 = np.diag([simopts.init_pos_std**2, simopts.init_pos_std**2, simopts.init_vel_std**2,simopts.init_vel_std**2])
    X0 = np.array([[0.0, 0.0, 0.0, 0.0]]).T
    I0 = np.array([[1, 0], [0, 1], [0, 0], [0, 0]])

    kf = KalmanFilter(F, H, Q, R, X0, P0, I0)
    return kf


def create_vehicle_model(simopts: SimulationOptions) -> VehicleModelA:
    """
    This function vehicle model with an initial position, velocity and heading.

    Parameters
    ----------
    simopts
        Simulation parameters used to configure the vehicle model.

    Returns
    -------
    vehicle_model
        The model of the vehicle that the Kalman filter needs to estimate the velocity and position of.
    """
    params = VehicleModelAParams(
        initial_x_position = (1000 * (np.random.rand() - 0.5)) if simopts.start_at_origin else 0.0,
        initial_y_position = (1000 * (np.random.rand() - 0.5)) if simopts.start_at_origin else 0.0,
        initial_speed = (np.random.rand() * 20) if simopts.start_at_random_speed else 10.0,
        initial_heading_rad = np.deg2rad((180 * (np.random.rand() - 0.5)) if simopts.start_at_random_heading else 45.0),
    )
    return VehicleModelA(params)


def vehicle_update(model: VehicleModelA, motion_type: str, dt: float, rand_param: float):
    """
    Update the vehicle model.

    Parameters
    ----------
    model
        The vehicle model to update.
    motion_type
        A string identifying what type of motion the vehicle should do.
    dt
        The time step since the last execution of the model.
    rand_param
        When executing the linear motion, this is the acceleration of the vehicle.
    """
    if motion_type == "random":
        model.update(dt, 2 * np.random.randn(), 2 * np.random.randn())
    elif motion_type == "circle":
        model.update(dt, 0 , np.deg2rad(360 / 120))
    elif motion_type == "linear":
        model.update(dt, rand_param, 0)
    else:
        model.update(dt, 0, 0)


def plot_analysis(history: History):
    """
    Plots the data generated by the simulation.
    """
    _, axs = plt.subplots(nrows=4, ncols=2, constrained_layout=True)

    axs[0, 0].set_title("X Position")
    axs[1, 0].set_title("Y Position")
    axs[2, 0].set_title("X Velocity")
    axs[3, 0].set_title("Y Velocity")
    axs[0, 1].set_title("X Position Error")
    axs[1, 1].set_title("Y Position Error")
    axs[2, 1].set_title("X Velocity Error")
    axs[3, 1].set_title("Y Velocity Error")

    for row in axs:
        for ax in row:
            ax.grid(True)

    axs[3, 0].set_xlabel('Time (sec)')
    axs[3, 1].set_xlabel('Time (sec)')
    axs[0, 0].set_ylabel('X Position (m)')
    axs[1, 0].set_ylabel('Y Position (m)')
    axs[2, 0].set_ylabel('X Velocity (m/s)')
    axs[3, 0].set_ylabel('Y Velocity (m/s)')

    # Plot Vehicle State
    axs[0, 0].plot(history.time, [v[0, 0] for v in history.vehicle_position], 'b')
    axs[1, 0].plot(history.time, [v[1, 0] for v in history.vehicle_position], 'b')
    axs[2, 0].plot(history.time, [v[0, 0] for v in history.vehicle_velocity], 'b')
    axs[3, 0].plot(history.time, [v[1, 0] for v in history.vehicle_velocity], 'b')

    # Plot Estimated States
    time_plot = [t for t, v in zip(history.time, history.estimated_state) if v is not None ]
    axs[0, 0].plot(time_plot, [v[0] for v in history.estimated_state if v is not None], 'r')
    axs[1, 0].plot(time_plot, [v[1] for v in history.estimated_state if v is not None], 'r')
    axs[2, 0].plot(time_plot, [v[2] for v in history.estimated_state if v is not None], 'r')
    axs[3, 0].plot(time_plot, [v[3] for v in history.estimated_state if v is not None], 'r')

    # Plot Measurements
    time_plot = [t for t,v in zip(history.time, history.measurement) if v is not None ]
    axs[0, 0].plot(time_plot, [v[0] for v in history.measurement if v is not None], 'k+')
    axs[1, 0].plot(time_plot, [v[1] for v in history.measurement if v is not None], 'k+')

    # Plot Errors
    time_plot = [t for t,v in zip(history.time, history.estimated_error) if v is not None ]
    axs[0, 1].plot(time_plot, [v[0] for v in history.estimated_error if v is not None], 'r')
    axs[1, 1].plot(time_plot, [v[1] for v in history.estimated_error if v is not None], 'r')
    axs[2, 1].plot(time_plot, [v[2] for v in history.estimated_error if v is not None], 'r')
    axs[3, 1].plot(time_plot, [v[3] for v in history.estimated_error if v is not None], 'r')
    
    time_plot = [t for t,v in zip(history.time, history.estimated_covariance) if v is not None ]
    axs[0, 1].plot(time_plot, [3.0*np.sqrt(v[0][0]) for v in history.estimated_covariance if v is not None], 'g')
    axs[1, 1].plot(time_plot, [3.0*np.sqrt(v[1][1]) for v in history.estimated_covariance if v is not None], 'g')
    axs[2, 1].plot(time_plot, [3.0*np.sqrt(v[2][2]) for v in history.estimated_covariance if v is not None], 'g')
    axs[3, 1].plot(time_plot, [3.0*np.sqrt(v[3][3]) for v in history.estimated_covariance if v is not None], 'g')
    axs[0, 1].plot(time_plot, [-3.0*np.sqrt(v[0][0]) for v in history.estimated_covariance if v is not None], 'g')
    axs[1, 1].plot(time_plot, [-3.0*np.sqrt(v[1][1]) for v in history.estimated_covariance if v is not None], 'g')
    axs[2, 1].plot(time_plot, [-3.0*np.sqrt(v[2][2]) for v in history.estimated_covariance if v is not None], 'g')
    axs[3, 1].plot(time_plot, [-3.0*np.sqrt(v[3][3]) for v in history.estimated_covariance if v is not None], 'g')


def run_sim(simopts: SimulationOptions):
    """
    Runs the simulation of a filter estimating the position of an object moving in a 2D plane.

    Parameters
    ----------
    simopts
        The set of user options to configure the simulation.
    """
    # Create the simulation objects
    vehicle_model = create_vehicle_model(simopts)
    kalman_filter = create_kalman_filter(simopts)

    # Save the initial states
    state, cov = kalman_filter.state()
    history = History(
        time = [0.0],
        vehicle_position = [vehicle_model.position()],
        vehicle_velocity = [vehicle_model.velocity()],
        measurement = [None],
        estimated_state = [state],
        estimated_covariance = [cov],
        estimated_error = [None],
        measurement_innovation = [None],
        measurement_innovation_covariance = [None],
    )

    # Run simulation
    rand_param = 0.1 * np.random.randn()
    k = 1
    while k * simopts.dt < simopts.end_time:

        # Execute vehicle model
        vehicle_update(vehicle_model, simopts.motion_type, simopts.dt, rand_param)
        vehicle_pos = vehicle_model.position()
        vehicle_vel = vehicle_model.velocity()
        
        # Kalman filter prediction
        kalman_filter.prediction()

        # Kalman filter update
        measurement = None
        if (k % simopts.measurement_decimation_factor) == 0:
            
            x_meas = vehicle_pos[0, 0] + np.random.randn() * simopts.actual_noise_std
            y_meas = vehicle_pos[1, 0] + np.random.randn() * simopts.actual_noise_std
            measurement = np.array([[x_meas, y_meas]]).T
            kalman_filter.update(measurement)
            innovation, innovation_cov = kalman_filter.innovation()
            history.measurement_innovation.append(innovation)
            history.measurement_innovation_covariance.append(innovation_cov)
            
        # Estimation error
        estimation_error = None
        estimated_state, cov = kalman_filter.state()
        if estimated_state is not None:
            estimation_error = estimated_state - np.vstack((vehicle_pos, vehicle_vel))
        
        # Save Data
        history.time.append(k * simopts.dt)
        history.vehicle_position.append(vehicle_model.position().copy())
        history.vehicle_velocity.append(vehicle_model.velocity().copy())
        history.measurement.append(measurement)
        history.estimated_state.append(estimated_state)
        history.estimated_covariance.append(cov)
        history.estimated_error.append(estimation_error)

        k += 1

    # Calculate Stats
    x_innov_std = np.std([v[0] for v in history.measurement_innovation if v is not None])
    y_innov_std = np.std([v[1] for v in history.measurement_innovation if v is not None])
    pos_mse = np.mean([(v[0]**2 + v[1]**2) for v in history.estimated_error if v is not None])
    vel_mse = np.mean([(v[2]**2 + v[3]**2) for v in history.estimated_error if v is not None])

    print(f"X Position Measurement Innovation Std: {x_innov_std} (m)")
    print(f"Y Position Measurement Innovation Std: {y_innov_std} (m)")
    print(f"Position Mean Squared Error: {pos_mse} (m)^2")
    print(f"Velocity Mean Squared Error: {vel_mse} (m/s)^2")

    if simopts.draw_plots:
        plot_analysis(history)
        plt.show()


###############################################################################
# MAIN
###############################################################################

if __name__ == "__main__":
    simopts = SimulationOptions(
        dt = 0.01,
        end_time = 120,
        measurement_decimation_factor = 2,
        actual_noise_std = 10,
        motion_type = "circle",
        start_at_origin = False,
        start_at_random_speed = True,
        start_at_random_heading = True,
        draw_plots = True,
        measurement_std = 10,
        accel_std = 0.5,
        init_pos_std = 40,
        init_vel_std = 20,
    )
    run_sim(simopts)
